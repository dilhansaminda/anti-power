use std::{
    collections::HashSet,
    env,
    fs,
    path::{Path, PathBuf},
};

fn main() {
    tauri_build::build();

    let manifest_dir =
        PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("Missing CARGO_MANIFEST_DIR"));
    let patches_dir = manifest_dir.join("..").join("patches");
    let exclude_path = patches_dir.join(".embed-exclude.txt");

    let exclude = read_exclude_list(&exclude_path);
    let mut files = Vec::new();
    collect_patch_files(&patches_dir, &patches_dir, &exclude, &mut files);
    files.sort();

    let output = render_embedded_list(&files);
    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("Missing OUT_DIR"));
    let out_path = out_dir.join("embedded_patches.rs");
    fs::write(&out_path, output).expect("Failed to write embedded patches list");

    println!("cargo:rerun-if-changed={}", patches_dir.display());
    println!("cargo:rerun-if-changed={}", exclude_path.display());
}

fn read_exclude_list(path: &Path) -> HashSet<String> {
    let mut entries = HashSet::new();
    entries.insert(".embed-exclude.txt".to_string());

    let content = match fs::read_to_string(path) {
        Ok(content) => content,
        Err(_) => return entries,
    };

    for line in content.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with('#') {
            continue;
        }
        entries.insert(trimmed.replace('\\', "/"));
    }

    entries
}

fn collect_patch_files(
    root: &Path,
    dir: &Path,
    exclude: &HashSet<String>,
    files: &mut Vec<String>,
) {
    let entries = match fs::read_dir(dir) {
        Ok(entries) => entries,
        Err(_) => return,
    };

    for entry in entries.flatten() {
        let path = entry.path();
        if path.is_dir() {
            collect_patch_files(root, &path, exclude, files);
            continue;
        }

        let rel = match path.strip_prefix(root) {
            Ok(rel) => rel,
            Err(_) => continue,
        };
        let rel_str = normalize_path(rel);
        if is_excluded(&rel_str, exclude) {
            continue;
        }

        println!("cargo:rerun-if-changed={}", path.display());
        files.push(rel_str);
    }
}

fn normalize_path(path: &Path) -> String {
    path.components()
        .map(|component| component.as_os_str().to_string_lossy())
        .collect::<Vec<_>>()
        .join("/")
}

fn is_excluded(path: &str, exclude: &HashSet<String>) -> bool {
    if exclude.contains(path) {
        return true;
    }

    exclude.iter().any(|entry| {
        let entry = entry.trim_end_matches('/');
        path == entry || path.starts_with(&format!("{}/", entry))
    })
}

fn render_embedded_list(files: &[String]) -> String {
    let mut output = String::new();
    output.push_str("// Auto-generated by build.rs. Do not edit manually.\n");
    output.push_str("pub const EMBEDDED_FILES: &[(&str, &str)] = &[\n");
    for rel in files {
        output.push_str(&format!(
            "    (\"{}\", include_str!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/../patches/{}\"))),\n",
            rel, rel
        ));
    }
    output.push_str("];\n");
    output
}
